<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>响应式</title>
</head>

<body>
  <script>

    let activeEffect

    const bucket = new WeakMap()
    const data = {
      text: 'hello world',
      foo: 1,
      bar: 1,
      isOk: true
    }

    function track(target, key) {
      if (!activeEffect) return

      let depsMap = bucket.get(target)
      if (!depsMap) {
        bucket.set(target, depsMap = new Map())
      }
      let deps = depsMap.get(key)
      if (!deps) {
        depsMap.set(key, deps = new Set())
      }
      deps.add(activeEffect)
      // 
      activeEffect.deps.add(deps)
    }
    function trigger(target, key) {
      const depsMap = bucket.get(target)
      if (!depsMap) return
      const effects = depsMap.get(key)


      const effectsToRun = new Set()
      effects && effects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
          effectsToRun.add(effectFn)
        }
      })
      effectsToRun.forEach(fn => {
        if (fn.options.scheduler) {
          fn.options.scheduler(fn)
        } else {
          fn()
        }

      })
    }
    const obj = new Proxy(data, {
      get(target, key) {
        track(target, key)

        return target[key]
      },
      set(target, key, value) {
        target[key] = value

        trigger(target, key)
      }
    })


    function cleanup(effectFn) {
      effectFn.deps.forEach(deps => deps.delete(effectFn))

      effectFn.deps.clear()
    }

    // effect函数的执行会直接或间接影响其他函数的执行，这是我们就说effect函数产生了副作用 
    const effectStack = []
    function effect(fn, options = {}) {

      const effectFn = () => {
        cleanup(effectFn)
        activeEffect = effectFn
        effectStack.push(effectFn)
        const res = fn()
        effectStack.pop()
        activeEffect = effectStack[effectStack.length - 1]

        return res
      }
      effectFn.deps = new Set()
      effectFn.options = options
      if (options.lazy) {
        return effectFn
      } else {
        effectFn()
      }
    }


    // 通过lazy,让函数懒执行(也就是说通过effect传入的副作用函数不会立即执行)
    // 由于在effect函数内部对副作用函数进行了包裹wrapEffect,调用effect后不会立即执行，而是返回wrapEffect
    // 此时wrapEffect函数是没有返回值的，为了实现computed，需要
    function computed(getter) {
      let dirty = true
      let res

      const effectFn = effect(getter, {
        lazy: true,
        scheduler() {
          dirty = true
          trigger(obj, 'value')
        }
      })
      const obj = {
        get value() {
          if (dirty) {
            res = effectFn() // 执行完成后，出栈，变成嵌套的那个副作用函数
            dirty = false
          }
          track(obj, 'value')
          return res
        }
      }

      return obj
    }


    const jobQueue = new Set()
    let isFlushing = false
    function flushJobs() {
      if (isFlushing) return
      isFlushing = true
      Promise.resolve().then(() => {
        jobQueue.forEach(fn => fn())
      }).finally(() => {
        isFlushing = false
        // jobQueue.clear()
      })
    }

    // debugger
    const sumRes = computed(() => obj.foo + obj.bar)

    effect(() => {
      // 在该副作用函数中读取 sumRes.value
      console.log(sumRes.value)
    })

    // 修改 obj.foo 的值
    
    obj.foo++



    // const foo = computed(() => {
    //   console.log('执行');
    //   return obj.foo
    // })
    // console.log(foo.value);
    // console.log(foo.value);
    // console.log(foo.value);

    // effect(()=> {
    //   obj.foo
    // }, {
    //   lazy: true
    // })

    // effect(()=> {
    //   console.log(obj.foo)
    // }, {
    //   scheduler: (fn)=> {
    //     // setTimeout(fn);
    //     // flushJobs(fn)
    //     jobQueue.add(fn)
    //     flushJob()
    //   }
    // })
    // obj.foo++
    // obj.foo++
    // console.log('结束了')

    // effect(()=> {
    //   // obj.foo++
    //   obj.foo = obj.foo + 1
    // })

    // effect(()=> {
    //   effect(()=> {
    //     obj.foo
    //     console.log('内层')
    //   })
    //   console.log('外层');
    //   obj.text
    // })

    // effect(()=> {
    //   console.log('执行');
    //   document.body.innerText = obj.isOk ? obj.text : 'not'
    //   // document.body.innerText = obj.text
    // })
    // effect(()=> {
    //   console.log('2');
    //   obj.text
    // })
  </script>
</body>

</html>